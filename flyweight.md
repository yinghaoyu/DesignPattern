# 享元模式

享元模式是一种**结构型**模式。

一个应用场景是：运用共享技术有效地支持大量细粒度的对象。主要解决

> 在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，
如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。

假设我们有一个子弹类，同时我们设计一个子弹池，子弹池负责提供子弹：

```cpp
class Bullet
{
 public:
  int m_id = random();
  bool m_living = true;
  Bullet(bool living)
  {
    m_living = living;
  }
};

class BulletPool
{
 public:
  std::list<Bullet*> bullets;
  BulletPool()
  {
    for(int i = 0; i < 10; i++)
    {
      bullets.push_back(new Bullet(true));
    }
  }
  Bullet* getBullet()
  {
    for(int i = 0; i < bullets.size(); i++)
    {
      if(bullets.at(i).living)
      {
        return bullets.at(i);
      }
    }
    return new Bullet(true);
  }
};
```

可以看到 `getBullet`逻辑，如果池子中有子弹，就拿池子中的子弹，如果没有，就 `new` 一个新的子弹返回。

享元模式一个具体应用：使用对象池对高并发下的内存进行管理

> 对于开发者来说，垃圾回收是不可控的，而且是无法避免的。但是，我们还是可以通过一些方法来降低垃圾回收的频率，
减少进程暂停的时长。我们知道，只有使用过被丢弃的对象才是垃圾回收的目标，所以，我们需要想办法在处理大量请求的同时，
尽量减少产生这种一次性的对象。比如说，我们可以把收到请求的 `Request` 对象在业务流程中一直传递下去，
而不是每执行一个步骤，就创建一个内容和 `Request` 对象差不多的新对象。这里面没有多少通用的优化方法。
对于需要频繁使用，占用内存较大的一次性对象，我们可以考虑自行回收并重用这些对象。
实现的方法是这样的：我们可以为这些对象建立一个对象池。
收到请求后，在对象池内申请一个对象，使用完后再放回到对象池中，这样就可以反复地重用这些对象，
非常有效地避免频繁触发垃圾回收。
